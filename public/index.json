[{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Understand how to push branches to a remote repository and manage remote branches.\n1. Push a Branch to Remote git push origin \u0026lt;branch-name\u0026gt; Example: git push origin feature-branch Practice pushing your branch to a remote repository. 2. Track a Remote Branch Locally git checkout --track origin/\u0026lt;branch-name\u0026gt; Example: git checkout --track origin/feature-branch 3. Pull Remote Changes into a Local Branch git pull origin \u0026lt;branch-name\u0026gt; Example: git pull origin main 4. Pull Changes from One Remote Branch into Another Local Branch git pull origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pulls changes from the main branch in the remote repository into the local feature branch. Example: git pull origin main:feature 5. Push Changes from One Local Branch into Another Remote Branch git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; This command pushes changes from the local main branch to the feature branch in the remote repository. Example: git push origin main:feature Scenario Problem: You need to update your local qa-test branch with the latest changes from the remote main branch. After updating, you also want to push any new commits from qa-test back to a remote branch named qa-test. How do you accomplish this?\nMore About Push Ex. Deleting a Remote Branch\n","permalink":"http://localhost:1313/posts/git-branching/git-branching4-pushing-and-pulling-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to push branches to a remote repository and manage remote branches.\u003c/p\u003e","title":"Git Branching4-Pushing and Pulling Branches"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":" Objective: Learn how to move a branch to point to a specific commit.\n1. Find the Commit Hash Use git log to find the hash of the commit you want to move the branch to. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Move a Branch to a Specific Commit git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-hash\u0026gt; Example: git branch -f feature-branch abcdef1234567890abcdef1234567890abcdef12 This command forces the branch \u0026lt;branch-name\u0026gt; to point to \u0026lt;commit-hash\u0026gt;. You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git branch -f feature-branch abcdef1 3. Checkout the Branch to Verify git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Verify that the branch is now pointing to the specified commit. Scenario Problem: You have a branch hotfix that needs to be moved to a previous commit to reapply specific fixes. After moving it, you need to ensure the branch is tested and merged back into main. What are the steps involved?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching5-moving-branches-to-specific-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to move a branch to point to a specific commit.\u003c/p\u003e","title":"Git Branching5-Moving Branches to Specific Commits"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to merge changes from one branch into another and manage branches.\n1. Merge a Branch into the Current Branch git merge \u0026lt;branch-name\u0026gt; Example: git merge new-feature 2. Delete a Branch Locally git branch -d \u0026lt;branch-name\u0026gt; Example: git branch -d new-feature Scenario Problem 1: You‚Äôve made several changes in the feature-update branch and committed them. Now, you realize that the changes also need to be tested in a separate branch called qa-test. How do you ensure the qa-test branch has the latest changes from feature-update without losing any commits, and then switch back to the main branch?\nProblem 2: You need to merge bugfix-2024 into release and then delete the bugfix-2024 branch, but bugfix-2024 has some unmerged commits. How do you handle this situation?\nMore About Merge Ex. Squash Merge vs Base Merge\n","permalink":"http://localhost:1313/posts/git-branching/git-branching3-merging-and-deleting-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to merge changes from one branch into another and manage branches.\u003c/p\u003e","title":"Git Branching3-Merging and Deleting Branches"},{"content":" Objective: Understand the basics of creating and switching branches.\n1. List All Branches git branch 2. Create a New Branch git branch \u0026lt;branch-name\u0026gt; Example: git branch feature-branch 3. Switch to a Branch git checkout \u0026lt;branch-name\u0026gt; Example: git checkout feature-branch Quiz Scenario: Implementing a New Feature Based on the Latest Development Branch: You need to implement a new feature but must ensure that it is developed based on the latest development branch. How do you create a new branch named new-feature?\nSolution To create a new branch named new-feature, first ensure you are on the latest development branch by using git checkout main (assuming main is your main development branch), then create the new branch using git branch new-feature\n","permalink":"http://localhost:1313/posts/git-branching/git-branching1-getting-started/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand the basics of creating and switching branches.\u003c/p\u003e","title":"Git Branching1-Getting Started"},{"content":" Objective: Make changes in branches and understand basic workflows.\n1. Create and Switch to a New Branch git checkout -b \u0026lt;branch-name\u0026gt; Example: git checkout -b new-feature 2. Make Changes and Commit Make some changes to files in your working directory. Add changes to the staging area: git add . Commit the changes: git commit -m \u0026#34;Add new feature\u0026#34; 3. Switch Back to the Main Branch git checkout main ","permalink":"http://localhost:1313/posts/git-branching/git-branching2-working-with-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Make changes in branches and understand basic workflows.\u003c/p\u003e","title":"Git Branching2-Working with Branches"},{"content":" Objective: Learn how to apply specific commits from one branch to another using cherry-picking.\n1. Find the Commit Hash to Cherry-Pick Use git log to find the hash of the commit you want to cherry-pick. git log Example output (commit hash highlighted): commit abcdef1234567890abcdef1234567890abcdef12 Author: Your Name \u0026lt;you@example.com\u0026gt; Date: Date Commit message 2. Cherry-Pick the Commit git cherry-pick \u0026lt;commit-hash\u0026gt; Example: git cherry-pick abcdef1234567890abcdef1234567890abcdef12 You can also use a shortened version of the hash (usually the first 7 characters), as long as it is unique enough to identify the commit. Example of shortened hash: git cherry-pick abcdef1 This command applies the changes from the specified commit to your current branch. 3. Resolve Conflicts (if any) If conflicts arise during the cherry-pick, Git will notify you. Resolve conflicts manually, then add and commit the resolved changes. git add \u0026lt;file-with-conflicts\u0026gt; git cherry-pick --continue Scenario Problem: You need to apply a specific commit from feature-branch to your release branch. The commit hash is abcdef1234567890abcdef1234567890abcdef12, but you encounter conflicts. How do you resolve this?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching6-cherry-picking-commits/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Learn how to apply specific commits from one branch to another using cherry-picking.\u003c/p\u003e","title":"Git Branching6-Cherry-Picking Commits"},{"content":" Objective: Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\nIntro: Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit.\n1. Rebase a Branch onto Another Branch Switch to the branch you want to rebase: git checkout \u0026lt;branch-to-rebase\u0026gt; Example: git checkout feature-branch\tRebase the current branch onto another branch (e.g., main): git rebase \u0026lt;target-branch\u0026gt; Example: git rebase main This moves the entire branch to start from the tip of \u0026lt;target-branch\u0026gt;, replaying your commits on top of it. 2. Resolve Conflicts During Rebase If conflicts arise during the rebase, Git will pause and prompt you to resolve them. Resolve conflicts manually, then add the resolved files: git add \u0026lt;file-with-conflicts\u0026gt; Continue the rebase process: git rebase --continue 3. Abort a Rebase (if necessary) If you want to stop the rebase process and return to the original state, use: git rebase --abort This will cancel the rebase and restore your branch to its previous state. 4. Interactive Rebase For advanced manipulation of commits, you can use interactive rebase: git rebase -i \u0026lt;base-commit\u0026gt; Example: git rebase -i HEAD~3 This opens an editor where you can reorder, squash, or edit commits. Follow the instructions in the editor to modify commits. 5. Rebasing vs. Merging Rebasing rewrites history by applying your changes on top of another branch, resulting in a linear commit history. Merging combines changes from different branches without rewriting history, which can create a merge commit. Scenario Problem: You need to rebase feature-branch onto the latest main branch. During the rebase, you encounter multiple conflicts. After resolving conflicts, you also want to squash the last two commits in feature-branch into a single commit before finalizing the rebase. How do you proceed?\nMore About Rebase Ex. Deep Dive into Rebase\n","permalink":"http://localhost:1313/posts/git-branching/git-branching7-rebasing-branches/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Understand how to rebase branches to integrate changes and maintain a cleaner commit history.\u003c/p\u003e","title":"Git Branching7-Rebasing Branches"},{"content":" Objective: Gain confidence in more complex branch operations.\n1. Rename a Branch git branch -m \u0026lt;new-branch-name\u0026gt; Example: git branch -m renamed-branch 2. Delete a Remote Branch git push origin --delete \u0026lt;branch-name\u0026gt; Example: git push origin --delete feature-branch 3. List Remote Branches git branch -r ","permalink":"http://localhost:1313/posts/git-branching/git-branching8-more-branch-operations/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Gain confidence in more complex branch operations.\u003c/p\u003e","title":"Git Branching8-More Branch Operations"},{"content":"Rebase What Rebase Does Rebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\nHere\u0026rsquo;s how rebasing works:\nRebase a Branch onto Another Branch: When you rebase feature-branch onto main, Git first determines the common ancestor of the two branches. Then, it takes all the commits from feature-branch that are not in main and re-applies them on top of main. git checkout feature-branch git rebase main Rebase Workflow: Rewind: Git temporarily removes the commits from feature-branch that are not in main, making it appear as if the branch is based on main. Replay: Git then applies each of the commits from feature-branch one by one onto the tip of main. How Rebase Affects Branching Rebasing can significantly affect how branches relate to each other. Here are some key points:\nLinear History: Rebasing creates a linear commit history, which can be easier to understand and follow. This is especially useful in collaborative projects where a clean history helps new contributors understand the changes that have been made. Conflicts: During the rebase process, if there are conflicting changes between the commits being rebased and the base branch (e.g., main), Git will pause and allow you to resolve these conflicts manually. After resolving conflicts, you continue the rebase. git add \u0026lt;resolved-file\u0026gt; git rebase --continue Changing Commit Hashes: Rebasing changes the commit hashes of the rebased commits because their parent commit has changed. This can be problematic if those commits have already been pushed to a shared repository because it requires a force push to update the remote branch. git push --force History Rewriting: Since rebase essentially rewrites history, it should be used with caution, particularly with shared branches. It\u0026rsquo;s generally safe to rebase local branches that haven\u0026rsquo;t been shared with others. For shared branches, it\u0026rsquo;s better to use merge. Avoiding Merge Commits: By using rebase, you can avoid unnecessary merge commits in the history. This makes the history cleaner but means you won\u0026rsquo;t see explicit points where branches were merged, which might hide the context of the changes. Example Scenario Consider this scenario:\nmain has commits A, B, and C. feature-branch has commits D and E based on commit B of main. main: A---B---C\r\\\rfeature: D---E After rebasing feature-branch onto main, the history would look like this:\nmain: A---B---C\r\\\rfeature: D\u0026#39;---E\u0026#39; Commits D and E are now reapplied on top of commit C in main, becoming D' and E'.\nUndo Rebase Undoing an Ongoing Rebase If you are in the middle of a rebase and want to stop and undo the changes:\nAbort the Rebase: This command will stop the rebase process and return your branch to the state it was in before the rebase started. git rebase ‚Äîabort This will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nThis will discard all changes made during the rebase and reset the branch to its original state before the rebase was initiated.\nScenario: You are in the middle of rebasing feature-branch onto main, but decide to abort the process.\nInitial State:\nmain: A---B---C\r\\\rfeature-branch: D---E During Rebase:\nYou start rebasing feature-branch onto main, and Git is in the process of replaying commits D and E.\nmain: A---B---C\r\\\rfeature-branch: (D---E) [In progress] Aborting the Rebase:\nUse the command:\ngit rebase --abort\rFinal State (after aborting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n```\rUndoing a Completed Rebase If you have already completed the rebase and want to undo it:\nUse the ORIG_HEAD Reference: After a rebase, Git temporarily saves the previous state of your branch in ORIG\\_HEAD. You can reset your branch to this state. git reset --hard ORIG_HEAD This will reset your branch to the state it was in before the rebase. Note that this command will discard any changes made during the rebase, so use it with caution. Scenario: You have completed rebasing feature-branch onto main, but decide to undo it.\nInitial State (before rebase):\nmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased feature-branch onto main.\nmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Undoing the Rebase:\nUse the command:\ngit reset --hard ORIG_HEAD\rFinal State (after resetting to ORIG_HEAD):\nmain: A---B---C\r\\\rfeature-branch: D---E Undoing a Pushed Rebase If you have already pushed the rebased branch to a remote repository, undoing the rebase becomes more complex, especially if others have already started working on the rebased branch. Here are the steps:\nInform Your Team: Communicate with your team to ensure no one else is working on the rebased branch or has pulled the changes. This is crucial to avoid conflicts and lost work. Reset the Local Branch: Reset your local branch to the previous state before the rebase using ORIG\\_HEAD. git reset --hard ORIG_HEAD 3. **Force Push to the Remote:**\rForce push the reset branch to the remote repository to overwrite the rebased history. This should be done carefully and only if you are sure no one else is affected. ```\rgit push --force Scenario: You completed the rebase but ORIG\\_HEAD is not available. You will use the reflog to find the previous state.\nInitial State (before rebase):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**After Rebase:** You have successfully rebased `feature-branch` onto `main`. ```\rmain: A---B---C\r\\\rfeature-branch: D\u0026#39;---E\u0026#39; Using Reflog:\nView the reflog to find the commit before the rebase.\ngit reflog You find that the commit hash before the rebase was B.\nResetting to the Previous Commit:\nUse the commit hash found in the reflog.\ngit reset --hard \u0026lt;commit-hash\u0026gt; Final State (after resetting):\nmain: A---B---C\r\\\rfeature-branch: D---E Using a Reflog for More Complex Cases If ORIG\\_HEAD is not available or you need to undo more complex changes, you can use Git\u0026rsquo;s reflog to find the commit before the rebase and reset to that commit.\nView the Reflog: The reflog shows a history of all actions (including rebases) that have affected the HEAD. git reflog Find the Commit Before the Rebase: Identify the commit hash before the rebase started. Reset to the Previous Commit: Reset your branch to that commit. git reset \u0026ndash;hard ### Scenario: You pushed the rebased `feature-branch` to the remote and now need to undo it. **Initial State (before rebase):** ```\rmain: A---B---C\r\\\rfeature-branch: D---E After Rebase:\nYou have successfully rebased and pushed feature-branch to the remote.\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026rsquo;\u0026mdash;E'\n**Resetting Locally:** Use `ORIG\\_HEAD` to reset your local branch to the state before the rebase. ```\rgit reset --hard ORIG_HEAD Final State (locally after resetting):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n**Force Pushing to Remote:** Force push to update the remote branch. ```\rgit push --force Final State (remote and local are now in sync):\n``` main: A\u0026mdash;B\u0026mdash;C feature-branch: D\u0026mdash;E\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deep-dive-into-rebase/","summary":"\u003ch1 id=\"rebase\"\u003eRebase\u003c/h1\u003e\n\u003ch2 id=\"what-rebase-does\"\u003eWhat Rebase Does\u003c/h2\u003e\n\u003cp\u003eRebasing in Git is a process that allows you to move or combine a sequence of commits to a new base commit. This is particularly useful for keeping your commit history linear and clean, which can make it easier to follow the changes in a project.\u003cbr\u003e\nHere\u0026rsquo;s how rebasing works:\u003c/p\u003e","title":"Git Branching Ex-Deep Dive into Rebase"},{"content":"üß© Intent The yield keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\nüí° Description yield return \u0026lt;value\u0026gt;: Produces a value to the enumerator and pauses execution until the next iteration.\nyield break: Terminates the iteration early.\nWhen a method uses yield, the C# compiler automatically generates a state machine that implements IEnumerable and IEnumerator. This allows the method to pause and resume execution seamlessly across iterations.\n‚öôÔ∏è Example IEnumerable\u0026lt;int\u0026gt; GetNumbers() { yield return 1; yield return 2; yield return 3; } foreach (var n in GetNumbers()) { Console.WriteLine(n); } Output:\n1\r2\r3 üö´ Early Termination Example IEnumerable\u0026lt;int\u0026gt; GetEvenNumbers(int max) { for (int i = 0; i \u0026lt;= max; i++) { if (i % 2 != 0) continue; if (i \u0026gt; 10) yield break; yield return i; } } This function stops producing values once i \u0026gt; 10.\nüß† Use Cases Generating sequences on demand (lazy evaluation)\nCustom iteration over data structures\nStreaming or paging large data sets\nSimplifying iterator logic without manually implementing IEnumerable\n‚öñÔ∏è Comparison Without yield With yield Must allocate a collection (e.g., List\u0026lt;T\u0026gt;) No extra collection needed Returns only after full computation Returns as soon as first value is ready Higher memory usage Lower memory footprint üß≠ Summary yield turns complex iterator logic into simple, readable code. It provides a pause-and-resume mechanism for methods, improving performance and readability in iterative scenarios.\nüìö References Microsoft Docs - yield (C# Reference)\nC# Iterators Overview\n","permalink":"http://localhost:1313/posts/csharp-keyword-yield/","summary":"\u003ch2 id=\"-intent\"\u003eüß© Intent\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eyield\u003c/code\u003e keyword simplifies the creation of iterators by allowing a method to produce a sequence of values lazily, one at a time, without building a collection in memory.\u003c/p\u003e","title":"C# Yield"},{"content":"When working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are squash merge and base (regular) merge. Each has its own use cases and implications for your commit history.\nBase (Regular) Merge A regular merge takes the contents of a source branch and integrates them into the target branch. This type of merge creates a merge commit that includes all the changes from the source branch, preserving the commit history.\nCharacteristics: Preserves Commit History: All commits from the source branch are preserved and visible in the commit history. Creates a Merge Commit: A new commit is created to represent the merge, indicating the point where the branches were combined. Commands: # Switch to the target branch git checkout main # Merge the feature branch into the target branch git merge feature-branch Example: main: A---B---C-------E\r\\ /\rfeature: D---F---G Here, E is the merge commit.\nSquash Merge A squash merge combines all the changes from the source branch into a single commit and then merges that commit into the target branch. This method does not preserve the individual commit history from the source branch.\nCharacteristics: Combines Commits: All commits from the source branch are combined into a single commit. Simplifies History: The commit history is simpler and cleaner, with only one commit representing all the changes from the source branch. Commands: # Switch to the target branch git checkout main # Squash and merge the feature branch into the target branch git merge --squash feature-branch # Commit the changes after squashing git commit -m \u0026#34;Squashed commit from feature-branch\u0026#34; Example: main: A---B---C---E\r\\\rfeature: D---F---G Here, E is the single commit representing all the changes from the feature-branch.\nComparison Aspect Base Merge Squash Merge Commit History Preserves all individual commits Combines all changes into a single commit, resulting in a simpler history Merge Commit Creates a merge commit No merge commit; a single squashed commit is added to the target branch Traceability Easier to trace the development history and individual changes Harder to trace individual changes but results in a cleaner history Use Cases Base (Regular) Merge: When you want to preserve the detailed commit history. Useful for large teams where individual contributions need to be tracked. When you need to maintain the context of each change. Squash Merge: When you prefer a clean and simplified commit history. Suitable for small, well-defined features or bug fixes. Ideal for repositories where keeping history concise is more important than individual commit details. ","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-squash-merge-vs-base-merge/","summary":"\u003cp\u003eWhen working with Git, merging is a crucial part of integrating changes from different branches. Two common types of merges are \u003cstrong\u003esquash merge\u003c/strong\u003e and \u003cstrong\u003ebase (regular) merge\u003c/strong\u003e. Each has its own use cases and implications for your commit history.\u003c/p\u003e","title":"Git Branching Ex-Squash Merge vs Base Merge"},{"content":" Objective: Learn how to delete a remote branch from your repository.\nBrief Introduction to the Command: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt;: This command deletes a specified branch from the remote repository. The \u0026lt;remote-name\u0026gt; is usually origin for the default remote repository, and \u0026lt;branch-name\u0026gt; is the name of the branch you want to delete. Steps: Identify the Branch to Delete: Make sure you know the exact name of the branch you want to delete. You can list all branches, including remote ones, with the command: git branch -a Delete the Remote Branch: Use the following command to delete the branch from the remote repository: git push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch-name\u0026gt; For example, if you want to delete a branch named feature-branch from the remote repository named origin: git push origin --delete feature-branch Shortened version: git push origin -d feature-branch Verify the Deletion: Fetch the latest state of the remote repository to update your local information about the remote branches: git fetch List the remote branches to ensure the branch has been deleted: git branch -r Example Workflow: List Remote Branches: git branch -r Output might look like: origin/HEAD -\u0026gt; origin/main origin/development origin/feature-branch origin/hotfix Delete the Remote Branch: git push origin -d feature-branch This command will delete feature-branch from the remote repository. Verify the Deletion: Fetch the latest state of the remote repository: git fetch List the remote branches again: git branch -r Output should no longer include origin/feature-branch: origin/HEAD -\u0026gt; origin/main origin/development origin/hotfix Problem: You have completed a feature and merged it into the main branch. Now you need to clean up by deleting the remote branch named old-feature. How do you delete this branch from the remote repository?\n","permalink":"http://localhost:1313/posts/git-branching/git-branching-ex-deleting-a-remote-branch/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eObjective\u003c/strong\u003e: Learn how to delete a remote branch from your repository.\u003c/p\u003e","title":"Git Branching Ex-Deleting a Remote Branch"}]